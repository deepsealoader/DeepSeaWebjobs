package routines;

import java.util.Date;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Clean
{	
	/**
     * filter: check if some key of a given JSON object contains some value.
     * 
     * 
     * {talendTypes} boolean
     * 
     * {Category} User Defined
     * 
     * {param} string("context") context: The JSON object.
     * {param} string("key") key: The key.
     * {param} string("value") value: The value to check.
     * 
     * {example} filter(context, "hashes", "123") # true.
     */
    public static boolean filter(org.json.JSONObject context, String key, String value) {
    	if (context == null || context.optString(key) == null) {
    		return true;
    	} else {
    		java.util.List<String> values = java.util.Arrays.asList(context.getString(key).split(","));
    		return !values.contains(value);
    	}
    }
    
	/**
     * cleanString: Returns true if not null or empty, otherwise returns false.
     * 
     * {talendTypes} boolean | Boolean
     * 
     * {Category} User Defined
     * 
     * {param} String("s") input: the string to clean
     * 
     * {example} cleanString("") # true
     */
	public static boolean isNullOrEmpty(String s) {
		return s == null || s.trim().equals("");
	}
	
	/**
     * cleanString: Returns a given string if not null or empty, otherwise returns null.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("s") input: the string to clean
     * 
     * {example} cleanString("") # null
     */
	public static String cleanString(String s) {
		if(Clean.isNullOrEmpty(s)) {
			return null;
		}

		return s;
	}
	
	/**
     * cleanString: Returns a given string if not null or empty, otherwise returns  a given
     * default string.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("s") input: the string to clean
     * {param} String("d") input: the default string
     * 
     * {example} cleanString("", "none") # "none"
     */
	public static String cleanString(String s, String d) {
		if(Clean.isNullOrEmpty(s)) {
			return cleanString(d);
		}

		return s;
	}
	
	/**
     * cleanNumber: Cleans a given string representing a number, removing comma, 
     * converting parenthesis as a negative, otherwise returns null.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("number") input: the string to clean
     * 
     * {example} cleanString("6,720.00") # "6720.00"
     */
	public static String cleanNumber(String number) {
		if(Clean.isNullOrEmpty(number)) {
			return null;
		}
		
		number = number.replaceAll("\\(", "-"); // Replace (XXX) by -XXX
		number = number.replaceAll(",|\\)", ""); // Removed format characters
		number = number.replaceAll("-+", "-"); // Removed duplicated minus characters
		return number;
	}
	
	/**
     * cleanDate: Cleans a given string representing a date and converting to "yyyy-MM-dd" format,
     * otherwise returns a default date.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("date") input: the string to clean
     * {param} String("defaultDate") input: the default date
     * {param} String("defaultFormat") input: the default format
     * 
     * {example} cleanDate("1975/06/12") # "1975-06-12"
     */
	public static String cleanDate(String date, String defaultDate, String defaultFormat) {
		if(Clean.isNullOrEmpty(date)) {
			return defaultDate;
		}
		
		if(checkDateFormat(date, DatePattern1)) {
			return date;
		}
		else if(checkDateFormat(date, DatePattern2)) {
			return date.replaceAll("/", "-");
		}
		else if(checkDateFormat(date, DatePattern3)) {
			return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("yyyyMMdd", date));
		}
		else if(checkDateFormat(date, DatePattern4)) {
			if(defaultDate == null) {
				if(defaultFormat == null) {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("MM/dd/yyyy", date));
				} else {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate(defaultFormat + "yy", date));
				}
			} else {
				Date date1 = TalendDate.parseDate("yyyy-MM-dd", defaultDate);
				Date date2 = TalendDate.parseDate("MM/dd/yyyy", date);
				if(TalendDate.getPartOfDate("MONTH", date1) == TalendDate.getPartOfDate("MONTH", date2) && TalendDate.getPartOfDate("YEAR", date1) == TalendDate.getPartOfDate("YEAR", date2)) {
					return TalendDate.formatDate("yyyy-MM-dd", date2);
				} else {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("dd/MM/yyyy", date));
				}
			}
		}
		else if(checkDateFormat(date, DatePattern5)) {
			if(defaultDate == null) {
				if(defaultFormat == null) {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("MM/dd/yy", date));
				} else {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate(defaultFormat, date));
				}
			} else {
				Date date1 = TalendDate.parseDate("yyyy-MM-dd", defaultDate);
				Date date2 = TalendDate.parseDate("MM/dd/yy", date);
				if(TalendDate.getPartOfDate("MONTH", date1) == TalendDate.getPartOfDate("MONTH", date2) && TalendDate.getPartOfDate("YEAR", date1) == TalendDate.getPartOfDate("YEAR", date2)) {
					return TalendDate.formatDate("yyyy-MM-dd", date2);
				} else {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("dd/MM/yy", date));
				}
			}
		}
		else if(checkDateFormat(date, DatePattern6)) {
			return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("yyMM", date));
		}
		else if(checkDateFormat(date, DatePattern7)) {
			return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("yyyyMM", date));
		}
		else if(checkDateFormat(date, DatePattern8)) {
			return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("yyyy/MM", date));
		}
		else {
			return defaultDate;
		}
	}

	/**
     * cleanFilename: Returns a given file name without extension, otherwise null if the string
     * is null or empty.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("filename") input: the file name
     * 
     * {example} cleanFilename("data.csv") # "data"
     */
	public static String cleanFilename(String filename) {
		if(Clean.isNullOrEmpty(filename)) {
			return null;
		}
		
		filename = filename.replaceAll("\\(.*\\)", ""); // Remove parts in parenthesis 
		filename = filename.replaceAll("\\..+$", ""); // Remove extensions
		
		return filename;
	}
	
	/**
     * codifyString: Buld a code from a stringh value.
     * 
     * {talendTypes} boolean | Boolean
     * 
     * {Category} User Defined
     *
     * {param} String("prefix") input: a prefix to prepend to the code
     * {param} String("s") input: the string to clean
     * 
     * {example} codifyString("Diamicron MR", "PRODUCT") # "PRODUCT_DIAMICRON_MR"
     */
	public static String codifyString(String prefix, String s) {
		if(Clean.isNullOrEmpty(s)) {
			return null;
		}
		
		s = s.trim().toUpperCase();
		s = s.replace(" \\+\\.\\/", "_");
		return prefix + "_" + s;
	}
	
	/*
	 * Helper function to check if a string is a date with a given format.
	 */
	private static boolean checkDateFormat(String stringDate, Pattern pattern) {
		Matcher matcher = pattern.matcher(stringDate);
		return matcher.find();
    }
	
	private static final Pattern DatePattern1 = Pattern.compile("^\\d{4}-\\d{2}-\\d{2}$");
	private static final Pattern DatePattern2 = Pattern.compile("^\\d{4}/\\d{2}/\\d{2}$");	
	private static final Pattern DatePattern3 = Pattern.compile("^\\d{4}\\d{2}\\d{2}$"); 
	private static final Pattern DatePattern4 = Pattern.compile("^\\d{1,2}/\\d{1,2}/\\d{4}$");
	private static final Pattern DatePattern5 = Pattern.compile("^\\d{1,2}/\\d{1,2}/\\d{2}$");
	private static final Pattern DatePattern6 = Pattern.compile("^\\d{2}\\d{2}$");
	private static final Pattern DatePattern7 = Pattern.compile("^\\d{4}\\d{2}$");
	private static final Pattern DatePattern8 = Pattern.compile("^\\d{4}/\\d{2}$");
}