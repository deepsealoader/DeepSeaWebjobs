package routines;

import java.util.Date;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Clean
{	
	/**
     * cleanString: Returns true if not null or empty, otherwise returns false.
     * 
     * {talendTypes} boolean | Boolean
     * 
     * {Category} User Defined
     * 
     * {param} String("s") input: the string to clean
     * 
     * {example} cleanString("") # true
     */
	public static boolean isNullOrEmpty(String s) {
		return s == null || s.trim().equals("");
	}
	
	/**
     * cleanString: Returns a given string if not null or empty, otherwise returns null.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("s") input: the string to clean
     * 
     * {example} cleanString("") # null
     */
	public static String cleanString(String s) {
		if(Clean.isNullOrEmpty(s)) {
			return null;
		}

		return s;
	}
	
	/**
     * cleanString: Returns a given string if not null or empty, otherwise returns  a given
     * default string.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("s") input: the string to clean
     * {param} String("d") input: the default string
     * 
     * {example} cleanString("", "none") # "none"
     */
	public static String cleanString(String s, String d) {
		if(Clean.isNullOrEmpty(s)) {
			return cleanString(d);
		}

		return s;
	}
	
	/**
     * cleanNumber: Cleans a given string representing a number, removing comma, 
     * converting parenthesis as a negative, otherwise returns null.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("number") input: the string to clean
     * 
     * {example} cleanString("6,720.00") # "6720.00"
     */
	public static String cleanNumber(String number) {
		return Clean.cleanNumber(number, null);
	}
	
	/**
     * cleanNumber: Cleans a given string representing a number, removing comma, 
     * converting parenthesis as a negative, otherwise returns a default value.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("number") input: the string to clean
     * {param} String("defaultValue") input: the default value
     * 
     * {example} cleanString("6,720.00", "0.00") # "6720.00"
     */
	public static String cleanNumber(String number, String defaultValue) {
		if(Clean.isNullOrEmpty(number)) {
			return defaultValue;
		}
		
		number = number.replaceAll("\\(", "-"); // Replace (000) by -000
		number = number.replaceAll(",|\\)", ""); // Removed format characters
		number = number.replaceAll("-+", "-"); // Removed duplicated minus characters
		return number;
	}
	
	/**
     * cleanDate: Cleans a given string representing a date and converting to "yyyy-MM-dd" format,
     * otherwise returns a default date.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("date") input: the string to clean
     * {param} String("defaultDate") input: the default date
     * {param} String("defaultFormat") input: the default format
     * 
     * {example} cleanDate("1975/06/12") # "1975-06-12"
     */
	public static String cleanDate(String date, String defaultDate, String defaultFormat) {
		if(Clean.isNullOrEmpty(date)) {
			return defaultDate;
		}
		
		if(checkDateFormat(date, DatePattern1)) {
			return date;
		}
		else if(checkDateFormat(date, DatePattern2)) {
			return date.replaceAll("/", "-");
		}
		else if(checkDateFormat(date, DatePattern3)) {
			return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("yyyyMMdd", date));
		}
		else if(checkDateFormat(date, DatePattern4)) {
			if(Clean.isNullOrEmpty(defaultDate)) {
				if(Clean.isNullOrEmpty(defaultFormat)) {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("MM/dd/yyyy", date));
				} else {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate(defaultFormat + "yy", date));
				}
			} else {
				Date date1 = TalendDate.parseDate("yyyy-MM-dd", defaultDate);
				Date date2 = TalendDate.parseDate("MM/dd/yyyy", date);
				if(TalendDate.getPartOfDate("MONTH", date1) == TalendDate.getPartOfDate("MONTH", date2) && TalendDate.getPartOfDate("YEAR", date1) == TalendDate.getPartOfDate("YEAR", date2)) {
					return TalendDate.formatDate("yyyy-MM-dd", date2);
				} else {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("dd/MM/yyyy", date));
				}
			}
		}
		else if(checkDateFormat(date, DatePattern5)) {
			if(Clean.isNullOrEmpty(defaultDate)) {
				if(Clean.isNullOrEmpty(defaultFormat)) {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("MM/dd/yy", date));
				} else {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate(defaultFormat, date));
				}
			} else {
				Date date1 = TalendDate.parseDate("yyyy-MM-dd", defaultDate);
				Date date2 = TalendDate.parseDate("MM/dd/yy", date);
				if(TalendDate.getPartOfDate("MONTH", date1) == TalendDate.getPartOfDate("MONTH", date2) && TalendDate.getPartOfDate("YEAR", date1) == TalendDate.getPartOfDate("YEAR", date2)) {
					return TalendDate.formatDate("yyyy-MM-dd", date2);
				} else {
					return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("dd/MM/yy", date));
				}
			}
		}
		else if(checkDateFormat(date, DatePattern6)) {
			return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("yyMM", date));
		}
		else if(checkDateFormat(date, DatePattern7)) {
			return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("yyyyMM", date));
		}
		else if(checkDateFormat(date, DatePattern8)) {
			return TalendDate.formatDate("yyyy-MM-dd", TalendDate.parseDate("yyyy/MM", date));
		}
		else {
			return defaultDate;
		}
	}

	/**
     * cleanFilename: Returns a given file name without extension, otherwise null if the string
     * is null or empty.
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} String("filename") input: the file name
     * 
     * {example} cleanFilename("data.csv") # "data"
     */
	public static String cleanFilename(String filename) {
		if(Clean.isNullOrEmpty(filename)) {
			return null;
		}
		
		filename = filename.replaceAll("\\(.*\\)", ""); // Remove parts in parenthesis 
		filename = filename.replaceAll("\\..+$", ""); // Remove extensions
		
		return filename;
	}
	
	/**
     * codifyString: Build a code from a string value.
     * 
     * {talendTypes} boolean | Boolean
     * 
     * {Category} User Defined
     *
     * {param} String("prefix") input: a prefix to prepend to the code
     * {param} String("s") input: the string to clean
     * 
     * {example} codifyString("Diamicron MR", "PRODUCT") # "PRODUCT_DIAMICRON_MR"
     */
	public static String codifyString(String prefix, String s) {
		if(Clean.isNullOrEmpty(s)) {
			return null;
		}
		
		s = s.trim().toUpperCase();
		s = s.replaceAll(" \\+\\.\\/", "_");
		return prefix + "_" + s;
	}
	
	/**
     * Hamming: return the Hamming similarity of 2 strings
     * 
     * {talendTypes} string | String
     * 
     * {Category} User Defined
     * 
     * {param} String("s1") input: a string
     * {param} String("s2") input: a string
     * 
     * {example} Hamming("hello", "hello") # 1
     */
	public static float Hamming(String s, String t) {
        if(s.length() != t.length()) {
            return 0.0f;
        }

        if (s.length() == 0) {
            return 0.0f;
        }

        int n = 0;
        for(int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == t.charAt(i)) {
                n++;
            }
        }
        return (float) Math.exp(n) / (float) Math.exp(s.length());
    }
    
	/**
     * JaroWinkler: return the JaroWinkler similarity of 2 strings
     * 
     * {talendTypes} string | String
     * 
     * {Category} User Defined
     * 
     * {param} String("s1") input: a string
     * {param} String("s2") input: a string
     * 
     * {example} JaroWinkler("hello", "hello") # 1
     */
    public static float JaroWinkler(String s, String t) {
        int s_len = s.length();
        int t_len = t.length();

        if (s_len == 0 && t_len == 0) {
            return 1.0f;
        }

        int match_distance = Integer.max(s_len, t_len) / 2 - 1;

        boolean[] s_matches = new boolean[s_len];
        boolean[] t_matches = new boolean[t_len];

        int matches = 0;
        int transpositions = 0;

        for (int i = 0; i < s_len; i++) {
            int start = Integer.max(0, i - match_distance);
            int end = Integer.min(i + match_distance + 1, t_len);

            for (int j = start; j < end; j++) {
                if (t_matches[j])
                    continue;
                if (s.charAt(i) != t.charAt(j))
                    continue;
                s_matches[i] = true;
                t_matches[j] = true;
                matches++;
                break;
            }
        }

        if (matches == 0)
            return 0;

        int k = 0;
        for (int i = 0; i < s_len; i++) {
            if (!s_matches[i])
                continue;
            while (!t_matches[k])
                k++;
            if (s.charAt(i) != t.charAt(k))
                transpositions++;
            k++;
        }

        return ((((float) matches / (float) s_len) + ((float) matches / (float) t_len)
                + (((float) matches - (float) transpositions / 2.0f) / (float) matches)) / 3.0f);
    }

    /**
     * Jaccard: return the Jaccard similarity of 2 strings
     * 
     * {talendTypes} string | String
     * 
     * {Category} User Defined
     * 
     * {param} String("s1") input: a string
     * {param} String("s2") input: a string
     * 
     * {example} Jaccard("hello", "hello") # 1
     */
    public static float Jaccard(String s1, String s2) {
        return Float.valueOf(Clean.intersect(s1, s2).length())
                / Float.valueOf(Clean.union(s1, s2).length());
    }

    /*
	 * Helper function to calculate the union of 2 strings
	 */
    private static String union(String s1, String s2) {
        String result = "";

        for (char c : s1.toCharArray()) {
            if (!result.contains(String.valueOf(c))) {
                result += c;
            }
        }

        for (char c : s2.toCharArray()) {
            if (!result.contains(String.valueOf(c))) {
                result += c;
            }
        }

        return result;
    }

    /*
	 * Helper function to calculate the intersection of 2 strings
	 */
    private static String intersect(String s1, String s2) {
        String result = "";

        for (char c : s1.toCharArray()) {
            if (!result.contains(String.valueOf(c)) && s2.contains(String.valueOf(c))) {
                result += c;
            }
        }

        return result;
    }
	
	/*
	 * Helper function to check if a string is a date with a given format.
	 */
	private static boolean checkDateFormat(String stringDate, Pattern pattern) {
		Matcher matcher = pattern.matcher(stringDate);
		return matcher.find();
    }
	
	private static final Pattern DatePattern1 = Pattern.compile("^\\d{4}-\\d{2}-\\d{2}$");
	private static final Pattern DatePattern2 = Pattern.compile("^\\d{4}/\\d{2}/\\d{2}$");	
	private static final Pattern DatePattern3 = Pattern.compile("^\\d{4}\\d{2}\\d{2}$"); 
	private static final Pattern DatePattern4 = Pattern.compile("^\\d{1,2}/\\d{1,2}/\\d{4}$");
	private static final Pattern DatePattern5 = Pattern.compile("^\\d{1,2}/\\d{1,2}/\\d{2}$");
	private static final Pattern DatePattern6 = Pattern.compile("^\\d{2}\\d{2}$");
	private static final Pattern DatePattern7 = Pattern.compile("^\\d{4}\\d{2}$");
	private static final Pattern DatePattern8 = Pattern.compile("^\\d{4}/\\d{2}$");
}